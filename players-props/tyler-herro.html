<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NBA Player Detail</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../style.css">
    <style>
                .minutes-badge {
                    position: absolute;
                    top: 10px;
                    left: 10px;
                    background: #1aff00;
                    color: #181f1b;
                    font-size: 1.01rem;
                    font-weight: 800;
                    border-radius: 8px;
                    padding: 4px 14px;
                    box-shadow: 0 0 10px 2px #00ff7f99;
                    z-index: 10;
                    border: 2px solid #8000ff;
                    letter-spacing: 0.5px;
                    text-shadow: 0 0 4px #00ff7f99;
                }
                .spreads-badge {
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    font-size: 1.01rem;
                    font-weight: 800;
                    border-radius: 8px;
                    padding: 4px 14px;
                    box-shadow: 0 0 10px 2px #00ff7f99;
                    z-index: 10;
                    border: 2px solid #8000ff;
                    letter-spacing: 0.5px;
                    text-shadow: 0 0 4px #00ff7f99;
                    background: #222b22;
                    color: #fff;
                    transition: background 0.2s, color 0.2s;
                }
        .player-detail-container { max-width: 950px; margin: 32px auto; background: #181f1b; border-radius: 18px; box-shadow: 0 0 32px 8px #8000ff65; padding: 32px 24px; }
        .player-detail-img { width: 180px; height: 180px; object-fit: contain; display: block; margin: 0 auto 12px auto; }
        .player-detail-badges { display: flex; justify-content: center; gap: 0.5em; margin-bottom: 1em; }
        .player-detail-badge { font-weight: bold; border-radius: 6px; padding: 0.1em 0.7em; font-size: 1em; display: inline-block; }
        .navbar-props {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5em;
            margin: 18px 0 18px 0;
        }
        .navbar-props button {
            background: #222b22;
            color: #00ff7f;
            border: 2px solid #00ff7f;
            border-radius: 8px;
            padding: 6px 10px;
            font-weight: 700;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            margin-bottom: 4px;
            white-space: nowrap;
        }
        .navbar-props button.active, .navbar-props button:hover {
            background: #00ff7f;
            color: #181f1b;
        }
        .table-responsive {
            width: 100%;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin-bottom: 18px;
        }
        .gamelog-table { width: 100%; border-collapse: collapse; margin-top: 18px; min-width: 600px; }
        .gamelog-table th, .gamelog-table td { border: 1px solid #333; padding: 6px 8px; text-align: center; }
        .gamelog-table th { background: #222b22; color: #00ff7f; }
        .gamelog-table td { background: #181f1b; color: #fff; }
        .gamelog-table td[style*='background:#ffe066'] {
            color: #181f1b !important;
            font-weight: 700;
        }
        .gamelog-table td[style*='background:#ff2d2d'] {
            color: #fff !important;
            font-weight: 700;
        }
        .gamelog-table td[style*='background:#1aff00'] {
            color: #181f1b !important;
            font-weight: 700;
        }
        a :hover {
            box-shadow: 0 4px 12px #8000ff88;

        }
    </style>
</head>
<body>
    <div style="text-align:center;margin-top:24px;">
        <a href="../props-trend.html" style="text-decoration:none;display:inline-block;">
            <img src="../Images/CG.jpg" alt="Home" style="height:48px;width:auto;border-radius:12px;box-shadow:0 2px 8px #8000ff44;vertical-align:middle;cursor:pointer;transition:box-shadow 0.2s;">
        </a>
    </div>
    <div style="display:flex;justify-content:center;margin:18px 0 0 0;gap:18px;">
        <div style="position:relative;width:340px;">
            <input id="player-search" type="text" placeholder="Search player..." autocomplete="off" style="width:100%;padding:10px 14px;border-radius:8px;border:2px solid #00ff7f;background:#181f1b;color:#fff;font-size:1.1em;outline:none;">
            <div id="search-suggestions" style="position:absolute;top:44px;left:0;width:100%;background:#222b22;border-radius:0 0 8px 8px;box-shadow:0 2px 8px #8000ff44;z-index:1000;display:none;"></div>
        </div>
        <button id="prev-player-btn" style="padding:10px 14px;border-radius:8px;border:2px solid #00ff7f;background:#181f1b;color:#00ff7f;font-size:1.1em;outline:none;cursor:pointer;" aria-disabled="true">&#8592; Prev</button>
        <select id="player-dropdown" style="padding:10px 14px;border-radius:8px;border:2px solid #00ff7f;background:#181f1b;color:#fff;font-size:1.1em;outline:none;min-width:220px;">
            <option value="">Select player...</option>
        </select>
        <button id="next-player-btn" style="padding:10px 14px;border-radius:8px;border:2px solid #00ff7f;background:#181f1b;color:#00ff7f;font-size:1.1em;outline:none;cursor:pointer;" aria-disabled="true">Next &#8594;</button>
    </div>
    <div class="player-detail-container" style="position:relative;">
        <div id="minutes-badge" class="minutes-badge" style="display:none;"></div>
        <img id="player-img" class="player-detail-img" src="" alt="Player Image">
        <span id="spread-badge" class="spreads-badge" style="position:absolute;top:10px;right:10px;font-size:1.01rem;font-weight:800;border-radius:8px;padding:4px 14px;box-shadow:0 0 10px 2px #00ff7f99;z-index:10;border:2px solid #8000ff;letter-spacing:0.5px;text-shadow:0 0 4px #00ff7f99;background:#222b22;color:#fff;transition:background 0.2s, color 0.2s;display:block;">Loading spread...</span>
        <div class="player-detail-badges" id="player-badges"></div>
        <h2 id="player-name" style="text-align:center;color:#fff;"></h2>
        <div id="prop-summary" style="display:flex;justify-content:center;gap:18px;margin-bottom:10px;"></div>
        <div class="navbar-props" id="prop-navbar"></div>
        <div id="gamelog-section"></div>
        <div id="odds-section" style="margin-top:32px;"></div>
        <div id="correlation-section" style="margin-top:32px;"></div>
    </div>
    <!-- Gamelog filter dropdown -->
    <div id="gamelog-filter-container" style="text-align:center;margin:18px 0 0 0;">
        <label for="gamelog-filter" style="color:#00ff7f;font-weight:700;margin-right:10px;" id="gamelog-filter-label">Show:</label>
        <select id="gamelog-filter" aria-labelledby="gamelog-filter-label" style="padding:8px 14px;border-radius:8px;border:2px solid #00ff7f;background:#181f1b;color:#fff;font-size:1em;outline:none;">
            <option value="5">Last 5 Games</option>
            <option value="10" selected>Last 10 Games</option>
            <option value="20">Last 20 Games</option>
            <option value="full">Full Season</option>
        </select>
    </div>
<script>
    // --- Spread badge logic from props-trend.html ---
    // Fetches a JSON file from the given path and returns the parsed object
    async function fetchJson(path) {
        const res = await fetch(path);
        return res.json();
    }

    // Maps NBA team abbreviations to their full names (must match latest.json exactly)
    const teamNameMap = {
        ATL: 'Atlanta Hawks', BOS: 'Boston Celtics', BKN: 'Brooklyn Nets', CHA: 'Charlotte Hornets', CHI: 'Chicago Bulls', CLE: 'Cleveland Cavaliers', DAL: 'Dallas Mavericks', DEN: 'Denver Nuggets', DET: 'Detroit Pistons', GSW: 'Golden State Warriors', HOU: 'Houston Rockets', IND: 'Indiana Pacers', LAC: 'LA Clippers', LAL: 'Los Angeles Lakers', MEM: 'Memphis Grizzlies', MIA: 'Miami Heat', MIL: 'Milwaukee Bucks', MIN: 'Minnesota Timberwolves', NOP: 'New Orleans Pelicans', NYK: 'New York Knicks', OKC: 'Oklahoma City Thunder', ORL: 'Orlando Magic', PHI: 'Philadelphia 76ers', PHX: 'Phoenix Suns', POR: 'Portland Trail Blazers', SAC: 'Sacramento Kings', SAS: 'San Antonio Spurs', TOR: 'Toronto Raptors', UTA: 'Utah Jazz', WAS: 'Washington Wizards'
    };

    /**
     * Sets the spread badge for a given team abbreviation.
     * Fetches odds data, finds the spread for the team, and updates the badge color and text accordingly.
     * @param {string} teamAbbr - NBA team abbreviation (e.g., 'BOS')
     */
    async function setSpreadBadge(teamAbbr) {
        let oddsData;
        try {
            oddsData = await fetchJson('../data/odds/latest.json');
        } catch (err) {
            const badge = document.getElementById('spread-badge');
            if (badge) {
                badge.textContent = 'Error loading spread';
            }
            return;
        }
        // Build a map of team full names to their spread values
        let teamSpreads = {};
        if (oddsData && Array.isArray(oddsData.events)) {
            oddsData.events.forEach(event => {
                if (event.home_team && event.best_spread && event.best_spread.home && typeof event.best_spread.home.point === 'number') {
                    teamSpreads[event.home_team] = event.best_spread.home.point;
                }
                if (event.away_team && event.best_spread && event.best_spread.away && typeof event.best_spread.away.point === 'number') {
                    teamSpreads[event.away_team] = event.best_spread.away.point;
                }
            });
        }
        // Get the full team name from abbreviation
        let fullTeamName = teamAbbr && teamNameMap[teamAbbr] ? teamNameMap[teamAbbr] : null;
        let spread = (fullTeamName && teamSpreads[fullTeamName] !== undefined) ? teamSpreads[fullTeamName] : null;
        const badge = document.getElementById('spread-badge');
        if (badge) {
            badge.style.display = 'block';
            badge.style.position = 'absolute';
            badge.style.top = '10px';
            badge.style.right = '10px';
            if (spread !== null && spread !== undefined) {
                // Color code the badge based on the spread value
                const absSpread = Math.abs(spread);
                let badgeColor = '';
                if (absSpread >= 7) {
                    badgeColor = 'background:#ff2d2d;color:#fff;';
                } else if (absSpread >= 5) {
                    badgeColor = 'background:#ffe066;color:#181f1b;';
                } else if (absSpread <= 3) {
                    badgeColor = 'background:#1aff00;color:#181f1b;';
                } else {
                    badgeColor = 'background:#222b22;color:#fff;';
                }
                badge.setAttribute('style', badge.getAttribute('style').replace(/background:[^;]+;color:[^;]+;/, '') + badgeColor + 'position:absolute;top:10px;right:10px;');
                badge.textContent = `${spread > 0 ? '+' : ''}${spread} spread`;
            } else {
                badge.setAttribute('style', badge.getAttribute('style').replace(/background:[^;]+;color:[^;]+;/, '') + 'background:#222b22;color:#fff;position:absolute;top:10px;right:10px;');
                badge.textContent = 'No spread data';
            }
        }
    }

    /**
     * Gets the team abbreviation from the badge element in the DOM.
     * @returns {string|null} - Team abbreviation or null if not found
     */
    function getPlayerTeamAbbr() {
        const teamBadge = document.querySelector('.team-badge');
        if (teamBadge) {
            return teamBadge.textContent.trim();
        }
        return null;
    }

    // If a team badge is present, set the spread badge for that team
    const playerTeamAbbr = getPlayerTeamAbbr();
    if (playerTeamAbbr) {
        setSpreadBadge(playerTeamAbbr);
    }
// Utility: get player slug from the current URL (e.g., 'tyler-kolek' from 'tyler-kolek.html')
function getPlayerSlug() {
    const parts = window.location.pathname.split('/');
    return parts[parts.length-1].replace('.html','');
}

// Utility: get NBA team color and text color for a given abbreviation
function getTeamColor(team) {
    const TEAM_COLORS = {
      ATL: {bg: '#E03A3E', text: '#fff'}, BOS: {bg: '#007A33', text: '#fff'}, BKN: {bg: '#000', text: '#fff'}, CHA: {bg: '#1D1160', text: '#fff'}, CHI: {bg: '#CE1141', text: '#fff'}, CLE: {bg: '#6F263D', text: '#fff'}, DAL: {bg: '#00538C', text: '#fff'}, DEN: {bg: '#0E2240', text: '#fff'}, DET: {bg: '#C8102E', text: '#fff'}, GSW: {bg: '#1D428A', text: '#FFC72C'}, HOU: {bg: '#CE1141', text: '#fff'}, IND: {bg: '#002D62', text: '#FDBB30'}, LAC: {bg: '#C8102E', text: '#fff'}, LAL: {bg: '#552583', text: '#FDB927'}, MEM: {bg: '#5D76A9', text: '#fff'}, MIA: {bg: '#98002E', text: '#fff'}, MIL: {bg: '#00471B', text: '#fff'}, MIN: {bg: '#0C2340', text: '#fff'}, NOP: {bg: '#0C2340', text: '#fff'}, NYK: {bg: '#006BB6', text: '#fff'}, OKC: {bg: '#007AC1', text: '#fff'}, ORL: {bg: '#0077C0', text: '#fff'}, PHI: {bg: '#006BB6', text: '#fff'}, PHX: {bg: '#1D1160', text: '#fff'}, POR: {bg: '#E03A3E', text: '#fff'}, SAC: {bg: '#5A2D81', text: '#fff'}, SAS: {bg: '#C4CED4', text: '#000'}, TOR: {bg: '#CE1141', text: '#fff'}, UTA: {bg: '#002B5C', text: '#fff'}, WAS: {bg: '#002B5C', text: '#fff'}
    };
    return TEAM_COLORS[team] || {bg:'#222', text:'#fff'};
}

async function renderPlayerPage() {
        // --- Correlation Matrix Helper ---
        /**
         * Calculates the Pearson correlation coefficient between two arrays.
         * Used to measure the relationship between a player's stat and a teammate's stat.
         * @param {number[]} x - Array of values for player
         * @param {number[]} y - Array of values for teammate
         * @returns {number|null} - Correlation coefficient or null if not computable
         */
        function pearsonCorrelation(x, y) {
            const n = x.length;
            if (n === 0) return null;
            const avgX = x.reduce((a, b) => a + b, 0) / n;
            const avgY = y.reduce((a, b) => a + b, 0) / n;
            let num = 0, denX = 0, denY = 0;
            for (let i = 0; i < n; i++) {
                const dx = x[i] - avgX;
                const dy = y[i] - avgY;
                num += dx * dy;
                denX += dx * dx;
                denY += dy * dy;
            }
            if (denX === 0 || denY === 0) return null;
            return num / Math.sqrt(denX * denY);
        }

    // Utility: create a URL-friendly slug from a player's name (e.g., 'Tyler Kolek' -> 'tyler-kolek')
    function nameToSlug(name) {
        return name.toLowerCase().replace(/ /g, '-').replace(/[.'é]/g, '').replace(/[^a-z0-9-]/g, '').replace(/^-+|-+$/g, '');
    }
    // --- Data Loading ---
    // Get the player slug from the URL
    const slug = getPlayerSlug();
    // Load all player prop data
    const playerData = await fetchJson('../PLAYER_UI_CARDS_PERFECT.json');
    // Load all player gamelogs
    const gamelogs = await fetchJson('../Player_Gamelogs25.json');
    // Load odds data (try/catch in case file is missing)
    let oddsData = [];
    try {
        oddsData = await fetchJson('../nba_player_odds.json');
    } catch (e) {
        oddsData = [];
    }
    // Load injury data (try/catch in case file is missing)
    let injuryData = [];
    try {
        injuryData = await fetchJson('../nba_injuries.json');
        console.log('[InjuryData] Loaded injury data:', injuryData);
    } catch (e) {
        console.error('[InjuryData] Failed to load injury data:', e);
        injuryData = [];
    }
    // --- Player Search Setup ---
    // Set up the player search bar and suggestions dropdown
    const searchInput = document.getElementById('player-search');
    const suggestionsDiv = document.getElementById('search-suggestions');
    // Get all unique player names, sorted alphabetically
    const allNames = Array.from(new Set(playerData.map(p => p.name))).sort();
    // Find the player object for the current page by slug
    const player = playerData.find(p => p.name && p.name.toLowerCase().replace(/[^a-z0-9]+/g, '-') === slug);

    // --- Previous/Next player navigation ---
    // Allows user to go to previous or next player alphabetically
    const prevBtn = document.getElementById('prev-player-btn');
    const nextBtn = document.getElementById('next-player-btn');
    function updateNavButtons() {
        if (!player) {
            prevBtn.disabled = true;
            nextBtn.disabled = true;
            return;
        }
        const idx = allNames.findIndex(n => nameToSlug(n) === nameToSlug(player.name));
        prevBtn.disabled = (idx === 0);
        nextBtn.disabled = (idx === allNames.length - 1);
        prevBtn.setAttribute('aria-disabled', prevBtn.disabled);
        nextBtn.setAttribute('aria-disabled', nextBtn.disabled);
    }
    prevBtn.onclick = function() {
        if (!player || prevBtn.disabled) return;
        const idx = allNames.findIndex(n => nameToSlug(n) === nameToSlug(player.name));
        if (idx > 0) {
            const prevIdx = idx - 1;
            window.location.href = `${nameToSlug(allNames[prevIdx])}.html`;
        }
    };
    nextBtn.onclick = function() {
        if (!player || nextBtn.disabled) return;
        const idx = allNames.findIndex(n => nameToSlug(n) === nameToSlug(player.name));
        if (idx < allNames.length - 1) {
            const nextIdx = idx + 1;
            window.location.href = `${nameToSlug(allNames[nextIdx])}.html`;
        }
    };
    updateNavButtons();

    // --- Player dropdown setup ---
    // Populates the dropdown with all player names and navigates to the selected player
    const dropdown = document.getElementById('player-dropdown');
    dropdown.innerHTML = '<option value="">Select player...</option>';
    allNames.forEach(name => {
        const opt = document.createElement('option');
        opt.value = nameToSlug(name);
        opt.textContent = name;
        dropdown.appendChild(opt);
    });
    // Set dropdown to current player if on a player page
    if (player) dropdown.value = nameToSlug(player.name);
    dropdown.addEventListener('change', function() {
        if (dropdown.value) {
            window.location.href = `${dropdown.value}.html`;
        }
    });

    // --- Player search event listeners ---
    // Handles input in the search bar and displays suggestions
    searchInput.addEventListener('input', function() {
        const val = searchInput.value.trim().toLowerCase();
        if (!val) {
            suggestionsDiv.style.display = 'none';
            suggestionsDiv.innerHTML = '';
            return;
        }
        // Fuzzy match: contains or starts with
        const matches = allNames.filter(n => n.toLowerCase().includes(val) || n.toLowerCase().replace(/[^a-z0-9]/g,'').includes(val)).slice(0,8);
        if (matches.length === 0) {
            suggestionsDiv.style.display = 'none';
            suggestionsDiv.innerHTML = '';
            return;
        }
        suggestionsDiv.innerHTML = matches.map(n => `<div class='search-suggestion' style='padding:10px 14px;cursor:pointer;border-bottom:1px solid #222;'>${n}</div>`).join('');
        suggestionsDiv.style.display = '';
        Array.from(suggestionsDiv.children).forEach((el, idx) => {
            el.onclick = () => {
                const slug = nameToSlug(matches[idx]);
                window.location.href = `${slug}.html`;
            };
        });
    });
    // Hide suggestions on blur (with delay for click)
    searchInput.addEventListener('blur', () => setTimeout(()=>{ suggestionsDiv.style.display='none'; }, 150));
    searchInput.addEventListener('focus', function() {
        if (suggestionsDiv.innerHTML) suggestionsDiv.style.display = '';
    });

    // --- Minutes badge ---
    // Shows the expected minutes for the player if available
    const minBadge = document.getElementById('minutes-badge');
    if (player && player.expected_minutes) {
        minBadge.textContent = Number(player.expected_minutes).toFixed(1) + ' min';
        minBadge.style.display = '';
    } else {
        minBadge.style.display = 'none';
    }
    // --- Player not found fallback ---
    if (!player) {
        document.getElementById('player-name').textContent = 'Player not found';
        return;
    }
    // --- Player image and name ---
    // Use NBA CDN image for consistency with props-trend.html
    function getPlayerImage(playerId) {
        return playerId ? `https://cdn.nba.com/headshots/nba/latest/260x190/${playerId}.png` : '';
    }
    document.getElementById('player-img').src = getPlayerImage(player.player_id);
    document.getElementById('player-name').textContent = player.name;
    // Set spread badge using player's team abbreviation
    if (player.team) {
        setSpreadBadge(player.team);
    }
    // --- Badges (team, opponent, position) ---
    const badgesDiv = document.getElementById('player-badges');
    badgesDiv.innerHTML = '';
    // Team badge
    if (player.team) {
        const c = getTeamColor(player.team);
        badgesDiv.innerHTML += `<span class='player-detail-badge' style='background:${c.bg};color:${c.text};'>${player.team}</span>`;
    }
    // Opponent badge + position badge (side by side)
    if (player.opponent) {
        const c = getTeamColor(player.opponent);
        badgesDiv.innerHTML += `<span class='player-detail-badge' style='background:${c.bg};color:${c.text};'>vs ${player.opponent}</span>`;
        let position = player.position;
        // Fallback: look up position from positions JSON if not present
        if (!position && player.name) {
            try {
                const posJson = await fetchJson('../nba_players_2025_26_positions.json');
                position = posJson[player.name] || '';
            } catch (e) {
                position = '';
            }
        }
        if (position) {
            badgesDiv.innerHTML += `<span class='player-detail-badge' style='background:#222b22;color:#fff;margin-left:2px;'>${position}</span>`;
        }
    }
    // --- Injury Badge and Table ---
    // Helper to normalize player names for matching (removes punctuation, lowercases, trims)
    function normalizeName(name) {
        return name
            .toLowerCase()
            .replace(/[.'’`´]/g, '')
            .replace(/[^a-z0-9 ]/g, '')
            .replace(/ +/g, ' ')
            .trim();
    }
    if (injuryData && player && player.name) {
        const normPlayerName = normalizeName(player.name);
        // Try to find injury info for this player
        let playerInjury = injuryData.find(p => p.name && normalizeName(p.name) === normPlayerName);
        // Fallback: try matching by player_id if available
        if (!playerInjury && player.player_id) {
            playerInjury = injuryData.find(p => p.id && p.id === player.player_id);
        }
        // Fallback: get all team injuries (not just this player)
        let teamInjuries = [];
        if (player.team) {
            teamInjuries = injuryData.filter(p => p.team && p.team === player.team && p.status && p.status !== 'Active');
        }
        // If player is injured, show a badge
        if (playerInjury && playerInjury.status && playerInjury.status !== 'Active') {
            let badgeColor = '#ff2d2d', badgeText = '#fff';
            if (playerInjury.status === 'GTD') { badgeColor = '#ffe066'; badgeText = '#181f1b'; }
            if (playerInjury.status === 'OFS' || playerInjury.status === 'OUT') { badgeColor = '#ff2d2d'; badgeText = '#fff'; }
            badgesDiv.innerHTML += `<span class='player-detail-badge' style='background:${badgeColor};color:${badgeText};'>${playerInjury.status}${playerInjury.details ? ': ' + playerInjury.details : ''}</span>`;
        }
        // Render injury table below correlation section if there are team injuries
        if (teamInjuries.length > 0) {
            let injuryHtml = `<h3 style='color:#00ff7f;text-align:center;margin-bottom:10px;'>Injury News (${player.team})</h3>`;
            injuryHtml += `<div class="table-responsive"><table class='gamelog-table' style='margin-bottom:0;'>`;
            injuryHtml += `<tr><th>PLAYER</th><th>STATUS</th><th>DETAIL</th><th>POS</th><th>REPORTED</th></tr>`;
            teamInjuries.forEach(inj => {
                let statusColor = '#fff', statusBg = '';
                if (inj.status === 'GTD') { statusBg = '#ffe066'; statusColor = '#181f1b'; }
                if (inj.status === 'OFS' || inj.status === 'OUT') { statusBg = '#ff2d2d'; statusColor = '#fff'; }
                injuryHtml += `<tr><td>${inj.name || ''}</td><td style='background:${statusBg};color:${statusColor};font-weight:700;'>${inj.status || ''}</td><td>${inj.details || inj.detail || ''}</td><td>${inj.position || ''}</td><td>${inj.reportedAt ? inj.reportedAt.split('T')[0] : ''}</td></tr>`;
            });
            injuryHtml += `</table></div>`;
            document.getElementById('correlation-section').insertAdjacentHTML('afterend', `<div id='injury-section'>${injuryHtml}</div>`);
        }
    }
    // --- Prop types navbar ---
    // Get all unique prop types for this player (e.g., Points, Rebounds, etc.)
    const propTypes = Array.from(new Set(playerData.filter(p => p.name === player.name).map(p => p.prop)));
    const navbar = document.getElementById('prop-navbar');
    navbar.innerHTML = '';
    /**
     * Renders the summary for a given prop type (line, projection, DVP, score)
     * @param {string} propType - The prop type to display (e.g., 'Points')
     */
    // --- Load DVP data (sync, only once) ---
    let dvpData = null;
    async function getDvpData() {
        if (dvpData) return dvpData;
        try {
            dvpData = await fetchJson('../DVP_2025_weighted.json');
        } catch (e) {
            dvpData = null;
        }
        return dvpData;
    }

    async function renderPropSummary(propType) {
        const propRow = playerData.find(p => p.name === player.name && p.prop === propType);
        const summaryDiv = document.getElementById('prop-summary');
        if (!propRow) {
            summaryDiv.innerHTML = '';
            return;
        }
        // Always get position from nba_players_2025_26_positions.json
        let position = player.position;
        if (!position && player.name) {
            try {
                const posJson = await fetchJson('../nba_players_2025_26_positions.json');
                position = posJson[player.name] || '';
            } catch (e) {
                position = '';
            }
        }
        // Normalize position for DVP lookup (PG/SG→G, PF/SF→F, C→C)
        let dvpPosition = '';
        if (['PG','SG','G'].includes(position)) dvpPosition = 'PG';
        else if (['PF','SF','F'].includes(position)) dvpPosition = 'SF';
        else if (position === 'C') dvpPosition = 'C';
        // Always get opponent from UI card JSON
        let opponentAbbr = propRow.opponent || player.opponent;
        // DVP badge logic (from DVP_2025_weighted.json)
        let dvpValue = null;
        let dvpBadge = '';
        const dvpJson = await getDvpData();
        // Debug log for DVP lookup
        console.log('[DVP DEBUG]', {
            player: player.name,
            position,
            dvpPosition,
            opponentAbbr,
            dvpJson: dvpJson && dvpPosition && opponentAbbr ? dvpJson[dvpPosition]?.[opponentAbbr] : null
        });
        if (dvpJson && dvpPosition && opponentAbbr) {
            if (dvpJson[dvpPosition] && dvpJson[dvpPosition][opponentAbbr] !== undefined) {
                dvpValue = dvpJson[dvpPosition][opponentAbbr];
            }
        }
        // Map propType to DVP stat key
        const dvpStatMap = {
            'Points': 'pts',
            'Rebounds': 'reb',
            'Assists': 'ast',
            'Steals': 'stl',
            'Blocks': 'blk',
            'Fantasy Score': 'fd',
            'Pts+Rebs+Asts': 'pra',
            'Pts+Rebs': 'pr',
            'Pts+Asts': 'pa',
            'Rebs+Asts': 'ra',
            '3PM': '3pm',
            'Turnovers': 'to'
        };
        const dvpStatKey = dvpStatMap[propType] || 'pts';
        if (dvpValue !== null && dvpValue !== undefined && dvpValue[dvpStatKey] && dvpValue[dvpStatKey].rank !== undefined) {
            let rank = Number(dvpValue[dvpStatKey].rank);
            let color = '#ffe066';
            // Conditional formatting: interpolate between red, yellow, green
            if (rank <= 1) color = '#ff2d2d'; // Red
            else if (rank >= 30) color = '#1aff00'; // Green
            else if (rank === 15) color = '#ffe066'; // Neutral
            else {
                // Linear interpolation between red (1), yellow (15), green (30)
                if (rank < 15) {
                    // Red to yellow
                    let percent = (rank - 1) / 14;
                    // Interpolate from #ff2d2d to #ffe066
                    let r = Math.round(255 + percent * (255 - 255));
                    let g = Math.round(45 + percent * (224 - 45));
                    let b = Math.round(45 + percent * (102 - 45));
                    color = `rgb(${r},${g},${b})`;
                } else {
                    // Yellow to green
                    let percent = (rank - 15) / 15;
                    // Interpolate from #ffe066 to #1aff00
                    let r = Math.round(255 - percent * (255 - 26));
                    let g = Math.round(224 + percent * (255 - 224));
                    let b = Math.round(102 - percent * (102 - 0));
                    color = `rgb(${r},${g},${b})`;
                }
            }
            dvpBadge = `<span style=\"background:#23232b;color:${color};padding:6px 18px;border-radius:8px;font-weight:700;font-size:1.1em;margin-left:8px;\">DVP Rank: <span style='color:${color};'>${rank}</span></span>`;
        } else {
            dvpBadge = `<span style=\"background:#23232b;color:#888;padding:6px 18px;border-radius:8px;font-weight:700;font-size:1.1em;margin-left:8px;\">DVP Rank: <span style='color:#888;'>N/A</span></span>`;
        }
        // ...inside async function renderPropSummary(propType)...
summaryDiv.innerHTML = `
    <span style="background:#222b22;color:#fff;padding:6px 18px;border-radius:8px;font-weight:700;font-size:1.1em;">
        ${propRow.prop} Line: <span style="color:#fff;">${propRow.line}</span>
    </span>
    <span style="background:#181f1b;color:#fff;padding:6px 18px;border-radius:8px;font-weight:700;font-size:1.1em;">
        Projection: <span style="color:#fff;">${Number(propRow.projection).toFixed(1)}</span>
    </span>
    <span style="background:#181f1b;color:#fff;padding:6px 18px;border-radius:8px;font-weight:700;font-size:1.1em;">
        <span style="color:#fff;font-weight:700;">Score:</span>
        <span style="display:inline-block;margin-left:8px;padding:2px 12px;border-radius:6px;${getScoreBadgeStyle(propRow.score)}font-weight:700;min-width:48px;text-align:center;background:#222b22;">
            ${Number(propRow.score).toFixed(1)}
        </span>
    </span>
    ${dvpBadge}
`;
    }

    // --- Score badge color scale ---
    function getScoreBadgeStyle(score) {
        // min: 30 (red), mid: 50 (yellow), max: 70 (green)
        let color = '#ff2d2d'; // default red
        if (score >= 70) {
            color = '#1aff00'; // green
        } else if (score >= 50) {
            // interpolate yellow to green
            let percent = (score - 50) / 20;
            // yellow: #ffe066 (255,224,102), green: #1aff00 (26,255,0)
            let r = Math.round(255 + percent * (26 - 255));
            let g = Math.round(224 + percent * (255 - 224));
            let b = Math.round(102 + percent * (0 - 102));
            color = `rgb(${r},${g},${b})`;
        } else if (score > 30) {
            // interpolate red to yellow
            let percent = (score - 30) / 20;
            // red: #ff2d2d (255,45,45), yellow: #ffe066 (255,224,102)
            let r = 255;
            let g = Math.round(45 + percent * (224 - 45));
            let b = Math.round(45 + percent * (102 - 45));
            color = `rgb(${r},${g},${b})`;
        }
        return `color:${color};`;
    }
    // Gamelog rendering function (define before use)
    // Move propMap outside so it's not redeclared
    const propMap = {
        'Points': ['PTS'],
        'Rebounds': ['REB'],
        'Assists': ['AST'],
        'Steals': ['STL'],
        'Blocks': ['BLK'],
        'Fantasy Score': ['FP'],
        'Pts+Rebs+Asts': ['PRA'],
        'Pts+Rebs': ['PR'],
        'Pts+Asts': ['PA'],
        'Rebs+Asts': ['RA']
    };
    window.showGamelogs = function(propType) {
        renderPropSummary(propType);
        const propRow = playerData.find(p => p.name === player.name && p.prop === propType);
        const line = propRow ? Number(propRow.line) : null;
        const highlightCols = propMap[propType] || [];
        Array.from(navbar.children).forEach(btn => btn.classList.remove('active'));
        Array.from(navbar.children).find(btn => btn.textContent === propType).classList.add('active');
        // Filter and sort games for this player (by GAME DATE descending)
        let logs = gamelogs.filter(g => g.PLAYER === player.name).sort((a, b) => {
            const parse = d => {
                if (!d || !d['GAME DATE']) return '';
                const [month, day, year] = d['GAME DATE'].split('/');
                return new Date(`${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`);
            };
            return parse(b) - parse(a);
        });
        if (currentGamelogFilter !== 'full') {
            logs = logs.slice(0, Number(currentGamelogFilter));
        }
        const columns = ['PTS','REB','AST','STL','BLK','FP','PRA','PR','PA','RA'];
        // Compute color for each cell in highlight columns
        let colColors = {};
        highlightCols.forEach(col => {
            let values = logs.map(g => {
                if (col === 'PRA') return (Number(g['PTS'])||0)+(Number(g['REB'])||0)+(Number(g['AST'])||0);
                if (col === 'PR') return (Number(g['PTS'])||0)+(Number(g['REB'])||0);
                if (col === 'PA') return (Number(g['PTS'])||0)+(Number(g['AST'])||0);
                if (col === 'RA') return (Number(g['REB'])||0)+(Number(g['AST'])||0);
                if (col === 'FP') return Number(g['FP'])||0;
                return Number(g[col])||0;
            });
            // Color scale: green for above line, red for below, gray for equal
            colColors[col] = values.map(val => {
                if (line === null) return '';
                if (val > line) return '#1aff00';
                if (val < line) return '#ff2d2d';
                return 'gray';
            });
        });
        let html = `<table class='gamelog-table'><tr><th>Date</th><th>Matchup</th><th>MIN</th>`;
        columns.forEach(col => {
            if (highlightCols.includes(col)) {
                html += `<th style='background:#00ff7f;color:#181f1b;'>${col}</th>`;
            } else {
                html += `<th>${col}</th>`;
            }
        });
        html += `</tr>`;
        logs.forEach((g, rowIdx) => {
            const PRA = (Number(g['PTS'])||0)+(Number(g['REB'])||0)+(Number(g['AST'])||0);
            const PR = (Number(g['PTS'])||0)+(Number(g['REB'])||0);
            const PA = (Number(g['PTS'])||0)+(Number(g['AST'])||0);
            const RA = (Number(g['REB'])||0)+(Number(g['AST'])||0);
            html += `<tr><td>${g['GAME DATE'] || ''}</td><td>${g['MATCH UP'] || ''}</td><td>${g['MIN'] || ''}</td>`;
            columns.forEach((col, colIdx) => {
                let val = g[col];
                if (col === 'FP' && val !== undefined) val = Number(val).toFixed(1);
                if (col === 'PRA') val = PRA.toFixed(1);
                if (col === 'PR') val = PR.toFixed(1);
                if (col === 'PA') val = PA.toFixed(1);
                if (col === 'RA') val = RA.toFixed(1);
                if (highlightCols.includes(col) && line !== null) {
                    // Use color for this cell in the column
                    let color = colColors[col][rowIdx];
                    html += `<td style='font-weight:bold;background:#191f1b;color:${color};'>${val}</td>`;
                } else {
                    html += `<td>${val !== undefined ? val : ''}</td>`;
                }
            });
            html += `</tr>`;
        });
        html += `</table>`;
        document.getElementById('gamelog-section').innerHTML = `<div class="table-responsive">${html}</div>`;

        // --- Odds Table Rendering (filtered by selected prop and PrizePicks line) ---
        const oddsSection = document.getElementById('odds-section');
        const playerOdds = oddsData.find(o => o.name && player && o.name.toLowerCase() === player.name.toLowerCase());
        if (!playerOdds) {
            oddsSection.innerHTML = '<div style="color:#888;text-align:center;margin-top:18px;">No odds data available for this player.</div>';
            return;
        }
        // Map propType to odds key
        const oddsPropMap = {
            'Points': 'points',
            'Assists': 'assists',
            'Rebounds': 'rebounds',
            'Steals': 'steals',
            'Blocks': 'blocks',
            'Turnovers': 'turnovers',
            'Pts+Rebs': 'pointsRebounds',
            'Pts+Asts': 'pointsAssists',
            'Rebs+Asts': 'reboundsAssists',
            'Pts+Rebs+Asts': 'pointsReboundsAssists',
            '3PM': 'threes',
            'Fantasy Score': 'fantasy'
        };
        const oddsKey = oddsPropMap[propType];
        const prop = playerOdds.projection && playerOdds.projection[oddsKey];
        if (!prop || !prop.books || prop.books.length === 0) {
            oddsSection.innerHTML = '<div style="color:#888;text-align:center;margin-top:18px;">No odds data for this prop.</div>';
            return;
        }
        // Find PrizePicks line for this prop
        let prizepicksBook = prop.books.find(b => b.book && b.book.toLowerCase().includes('prizepicks'));
        let targetLine = prizepicksBook ? prizepicksBook.value : null;
        // Fallback: use prop.summary.manualOU if PrizePicks not found
        if (targetLine === null && prop.summary && prop.summary.manualOU !== undefined) {
            targetLine = prop.summary.manualOU;
        }
        // Only show odds that match the PrizePicks line
        const filteredBooks = prop.books.filter(b => b.value === targetLine);
        let oddsHtml = `<h3 style=\"color:#00ff7f;text-align:center;margin-bottom:10px;\">${propType} Odds (Line: ${targetLine !== null ? targetLine : 'N/A'})</h3>`;
        if (filteredBooks.length === 0) {
            oddsHtml += '<div style=\"color:#888;text-align:center;margin-top:18px;\">No odds at PrizePicks line for this prop.</div>';
        } else {
            // Helper to color scale implied probability
            function getProbColorStyle(prob) {
                if (typeof prob !== 'number' || isNaN(prob)) return 'color:#fff;';
                const percent = prob * 100;
                let color = '#ff2d2d'; // red
                if (percent >= 60) {
                    color = '#1aff00'; // green
                } else if (percent >= 50) {
                    // yellow to green
                    let p = (percent - 50) / 10;
                    let r = Math.round(255 + p * (26 - 255));
                    let g = Math.round(224 + p * (255 - 224));
                    let b = Math.round(102 + p * (0 - 102));
                    color = `rgb(${r},${g},${b})`;
                } else if (percent > 40) {
                    // red to yellow
                    let p = (percent - 40) / 10;
                    let r = 255;
                    let g = Math.round(45 + p * (224 - 45));
                    let b = Math.round(45 + p * (102 - 45));
                    color = `rgb(${r},${g},${b})`;
                }
                return `color:${color};font-weight:700;`;
            }
            oddsHtml += `<div class=\"table-responsive\"><table class='gamelog-table' style='margin-bottom:0;'>`;
            oddsHtml += `<tr><th>Book</th><th>Line</th><th>Over</th><th>Under</th><th>Over Prob</th><th>Under Prob</th></tr>`;
            // Helper to calculate implied probability from American odds
            function impliedProb(odds) {
                if (odds === null || odds === undefined || isNaN(odds)) return '';
                odds = Number(odds);
                if (odds > 0) {
                    return (100 / (odds + 100));
                } else {
                    return (-odds / (-odds + 100));
                }
            }
            // Robust logo mapping: lower-case, remove non-letters, handle variations
            function getLogoFile(bookName) {
                if (!bookName) return '';
                const key = bookName.toLowerCase().replace(/[^a-z]/g, '');
                const map = {
                    'fanduel': 'fanduel.png',
                    'draftkings': 'draftkings.png',
                    'fanatics': 'fanatics.png',
                    'underdog': 'underdog.png',
                    'prizepicks': 'prizepicks.png',
                    'sleeper': 'sleeper.png',
                    'thescore': 'thescore.png',
                    'prophetx': 'prophetx.png',
                    'bovada': 'bovada.png',
                    'betmgm': 'betmgm.png',
                    'pointsbet': 'pointsbet.png',
                    'betrivers': 'betrivers.png',
                    'hardrockbet': 'hardrockbet.png',
                    'hardrock': 'hardrockbet.png',
                    'hardrockbetbet': 'hardrockbet.png',
                    'hardrockbetting': 'hardrockbet.png',
                    'caesars': 'caesars.png',
                    'fanatics': 'fanatics.png'
                };
                return map[key] || '';
            }
            filteredBooks.forEach(book => {
                let over = book.overPrice, under = book.underPrice;
                let overProb = over !== undefined && over !== null && over !== '' ? impliedProb(over) : '';
                let underProb = under !== undefined && under !== null && under !== '' ? impliedProb(under) : '';
                let bookName = book.book || '';
                let logoFile = getLogoFile(bookName);
                // console.log('[Sportsbook Logo Debug]', {bookName, logoFile});
                let logoImg = logoFile ? `<img src="../assets/team-logos/${logoFile}" alt="${bookName}" style="height:22px;vertical-align:middle;margin-right:6px;">` : '';
                oddsHtml += `<tr><td>${logoImg}${bookName}</td><td>${book.value !== undefined ? book.value : ''}</td><td>${over !== undefined ? over : ''}</td><td>${under !== undefined ? under : ''}</td><td><span style="${getProbColorStyle(overProb)}">${overProb !== '' ? (overProb * 100).toFixed(1) + '%' : ''}</span></td><td><span style="${getProbColorStyle(underProb)}">${underProb !== '' ? (underProb * 100).toFixed(1) + '%' : ''}</span></td></tr>`;
            });
            oddsHtml += `</table></div>`;
        }
        oddsSection.innerHTML = oddsHtml;
    }
    // --- Gamelog Filter Logic ---
    let currentGamelogFilter = '10';
    document.getElementById('gamelog-filter').addEventListener('change', function() {
        currentGamelogFilter = this.value;
        // Re-render the gamelog table for the current prop
        const activeBtn = Array.from(document.getElementById('prop-navbar').children).find(btn => btn.classList.contains('active'));
        if (activeBtn) {
            window.showGamelogs(activeBtn.textContent);
        }
    });
    // Now render navbar and call showGamelogs
    propTypes.forEach((prop, idx) => {
        navbar.innerHTML += `<button class='${idx===0?'active':''}' onclick='showGamelogs("${prop}")'>${prop}</button>`;
    });
    // Show gamelogs for first prop by default
    if (propTypes.length > 0) {
        showGamelogs(propTypes[0]);
    }
}
renderPlayerPage();
</script>
</body>
</html>
