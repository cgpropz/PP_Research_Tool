<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CGEDGE</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Roboto:wght@400;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="style.css" />
  <script>
    // Set base path for GitHub Pages subpath routing
    (function(){
      var base = document.createElement('base');
      var repo = '/NBA-UI-Props/';
      var inRepo = location.pathname.indexOf(repo) !== -1;
      base.href = inRepo ? repo : '/';
      document.head.appendChild(base);
    })();
  </script>
</head>
<body class="dashboard">

  <div class="header" style="position:relative;">
    <img src="Images/CG.jpg" alt="Logo" class="logo" style="position:absolute;left:16px;top:8px;width:64px;height:64px;object-fit:cover;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.35);">
    <h1>CGEDGE</h1>
    <div class="tagline" style="display:flex;align-items:center;gap:16px;flex-wrap:wrap;justify-content:center;">
      <nav style="display:flex;gap:14px;align-items:center;">
        <a href="./index.html" style="color:#00ff9d;text-decoration:none;font-weight:700">Player Props</a>
        <a href="./Team_Matchup.html" style="color:#00ff9d;text-decoration:none;font-weight:700">Team Matchups <span id="matchupCount" style="margin-left:6px;background:#002b36;color:#00ff9d;border:1px solid #00ff9d;border-radius:10px;padding:2px 6px;font-size:12px;vertical-align:middle"></span></a>
        <span id="oddsMeta" style="margin-left:10px;background:#002b36;color:#00ff9d;border:1px solid #00ff9d;border-radius:10px;padding:2px 6px;font-size:12px;vertical-align:middle">Odds: —</span>
        <a href="./Team_DVP.html" style="color:#00ff9d;text-decoration:none;font-weight:700">Team DVP</a>
        <a href="./Team_Rankings.html" style="color:#00ff9d;text-decoration:none;font-weight:700">Team Rankings</a>
        <button id="refreshBtn" style="margin-left:12px;background:#002b36;color:#00ff9d;border:1px solid #00ff9d;border-radius:10px;padding:2px 10px;font-size:12px;cursor:pointer">Refresh Data</button>
        <span id="slipCount" style="margin-left:10px;background:#002b36;color:#00ff9d;border:1px solid #00ff9d;border-radius:10px;padding:2px 8px;font-size:12px;vertical-align:middle;display:none">Slip: 0/6</span>
        <button id="openPPProfile" style="margin-left:12px;background:#232832;color:#39d9a9;border:1px solid #39d9a966;border-radius:10px;padding:2px 10px;font-size:12px;cursor:pointer">Open My PP Profile</button>
      </nav>
    </div>
  </div>

    <div class="controls">
    <div style="display:flex;flex-wrap:wrap;gap:12px;align-items:flex-start;justify-content:center;">
      <div class="filter-box" style="background:#0b1a20;border:1px solid #00ff9d;border-radius:10px;padding:10px 12px;display:flex;gap:10px;align-items:center;box-shadow:0 0 14px rgba(0,255,157,0.35), inset 0 0 6px rgba(0,255,157,0.15);">
        <input type="text" id="search" list="playerSuggestions" placeholder="Search player name..." />
        <datalist id="playerSuggestions"></datalist>
        <select id="statFilter">
      <option value="">All Props</option>
      <option value="Points">Points</option>
      <option value="Rebounds">Rebounds</option>
      <option value="Assists">Assists</option>
      <option value="Threes">Threes</option>
      <option value="Fantasy Score">Fantasy Score</option>
      <option value="Steals">Steals</option>
      <option value="Blocks">Blocks</option>
      <option value="Turnovers">Turnovers</option>
      <option value="Steals + Blocks">Steals + Blocks</option>
      <option value="Pts+Rebs+Asts">Pts+Rebs+Asts</option>
      <option value="Pts+Rebs">Pts+Rebs</option>
      <option value="Pts+Asts">Pts+Asts</option>
      <option value="Rebs+Asts">Rebs+Asts</option>
        </select>
        <select id="teamFilter">
          <option value="">All Teams</option>
        </select>
      </div>
      <div class="filter-box" style="background:#0b1a20;border:1px solid #00ff9d;border-radius:10px;padding:10px 12px;display:flex; gap:10px; align-items:center;box-shadow:0 0 14px rgba(0,255,157,0.35), inset 0 0 6px rgba(0,255,157,0.15);">
      <label style="color:#00ff9d; font-weight:bold;">Min Hit % →</label>
      <select id="minHitFilter">
        <option value="0">Any</option>
        <option value="60">60%+</option>
        <option value="70" selected>70%+</option>
        <option value="80">80%+</option>
        <option value="90">90%+</option>
      </select>
      <select id="hitPeriod">
        <option value="last_10_pct">Last 10</option>
        <option value="last_5_pct">Last 5</option>
        <option value="last_20_pct">Last 20</option>
        <option value="season_pct">Full Season</option>
      </select>
      </div>
      <div class="filter-box" style="background:#0b1a20;border:1px solid #00ff9d;border-radius:10px;padding:10px 12px;display:flex; gap:10px; align-items:center;box-shadow:0 0 14px rgba(0,255,157,0.35), inset 0 0 6px rgba(0,255,157,0.15);">
        <label style="color:#00ff9d; font-weight:bold;">Projection</label>
        <select id="projectionSort">
          <option value="none">No Sort</option>
          <option value="desc">High → Low</option>
          <option value="asc">Low → High</option>
        </select>
        <label style="color:#00ff9d; font-weight:bold;">DVP</label>
        <select id="dvpSort">
          <option value="none">No Sort</option>
          <option value="desc">High → Low</option>
          <option value="asc">Low → High</option>
        </select>
        <label style="color:#00ff9d; font-weight:bold;">Position</label>
        <select id="positionSort">
          <option value="none">No Sort</option>
          <option value="customAsc">PG → SG → PF → SF → C</option>
          <option value="customDesc">C → SF → PF → SG → PG</option>
        </select>
      </div>
    </div>
  </div>

  <div id="cards" class="cards-container"></div>

  <!-- Sticky Slip Bar -->
  <div id="slipBar" style="position:fixed;bottom:16px;left:50%;transform:translateX(-50%);width:min(1100px,94vw);background:rgba(22,27,34,0.85);backdrop-filter:blur(8px);border:1px solid var(--pp-border);border-radius:18px;padding:12px;box-shadow:0 8px 22px rgba(0,0,0,0.45);display:none;z-index:1000">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap">
      <div style="display:flex;align-items:center;gap:10px;flex:1;flex-wrap:wrap" id="slipItems"></div>
      <div id="slipInlineCount" style="background:#002b36;color:#00ff9d;border:1px solid #00ff9d;border-radius:10px;padding:4px 8px;font-size:12px;display:none">0/6 selected</div>
      <div style="display:flex;align-items:center;gap:8px">
        <button id="clearSlip" style="background:#2a2f37;color:#ff6b6b;border:1px solid #ff6b6b66;border-radius:10px;padding:6px 10px;font-weight:700;cursor:pointer">Clear</button>
        <button id="reviewSlip" style="background:#003322;color:#39d9a9;border:1px solid #39d9a966;border-radius:10px;padding:6px 12px;font-weight:700;cursor:pointer">Review Slip</button>
      </div>
    </div>
  </div>

  <!-- Review Modal -->
  <div id="slipModal" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.55);z-index:1001">
    <div style="width:min(820px,95vw);background:#161b22;border:1px solid var(--pp-border);border-radius:18px;box-shadow:0 10px 28px rgba(0,0,0,0.6);padding:18px">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px">
        <div style="font-weight:800;color:#fff;letter-spacing:.6px">Your Slip</div>
        <button id="closeSlip" style="background:#2a2f37;color:#cbd5e1;border:1px solid #475569;border-radius:10px;padding:6px 10px;cursor:pointer">Close</button>
      </div>
      <div id="slipSummary" style="display:grid;grid-template-columns:1fr;gap:8px;margin-bottom:12px"></div>
      <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;justify-content:flex-end">
        <button id="copySlip" style="background:#232832;color:#ffd43b;border:1px solid #ffd43b55;border-radius:10px;padding:8px 12px;font-weight:800;cursor:pointer">Copy Slip</button>
        <button id="copyCgpp" style="background:#232832;color:#00ff9d;border:1px solid #00ff9d55;border-radius:10px;padding:8px 12px;font-weight:800;cursor:pointer">Copy cgpp</button>
        <button id="openPP" style="background:#003322;color:#39d9a9;border:1px solid #39d9a966;border-radius:10px;padding:8px 12px;font-weight:800;cursor:pointer">Open PrizePicks</button>
      </div>
    </div>
  </div>

  <script>
    let allPlayers = [];
    let positionsMap = {};
    let dvpRankings = [];

    // Prefill search from query param (?search=Name)
      // Open PP profile convenience
      (function(){
        const btn = document.getElementById('openPPProfile');
        if(!btn) return;
        btn.addEventListener('click', ()=>{
          // Replace with your profile path if needed
          const profile = 'https://app.prizepicks.com/p/YSiy5hC4';
          window.open(profile, '_blank');
        });
      })();
    (function(){
      try{
        const params = new URLSearchParams(window.location.search);
        const q = params.get('search');
        if (q) {
          const el = document.getElementById('search');
          if (el) el.value = q;
        }
      }catch(e){}
    })();

    function slugify(name) {
      return name.toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/(^-|-$)/g, '');
    }
      // Build Basketball-Reference headshot URL from player name
      function bbrefHeadshot(name){
        const norm = (name || '').normalize('NFKD').replace(/[\u0300-\u036f]/g,'');
        const parts = norm.toLowerCase().split(/\s+/).filter(Boolean).map(p=>p.replace(/[^a-z]/g,''));
        if(parts.length < 2) return '';
        const first = parts[0], last = parts[parts.length-1];
        const slug = `${last.slice(0,5)}${first.slice(0,2)}01`;
        return `https://www.basketball-reference.com/req/202106291/images/players/${slug}.jpg`;
      }

    function getColor(pct) {
      if (pct >= 75) return 'hit-green';
      if (pct >= 60) return 'hit-neutral';
      if (pct < 45) return 'hit-red';
      return ''; // between 45 and 59 stays default color
    }

    function getPositionFor(name){
      if (!name || !positionsMap) return '';
      if (positionsMap[name]) return positionsMap[name];
      const key = Object.keys(positionsMap).find(k => k.toLowerCase() === String(name).toLowerCase());
      return key ? positionsMap[key] : '';
    }

    function positionOrderIndex(pos){
      const p = String(pos||'').toUpperCase();
      const order = { 'PG': 0, 'SG': 1, 'PF': 2, 'SF': 3, 'C': 4 };
      return (p in order) ? order[p] : 999;
    }

    // DVP helpers in global scope
    function mapStatToDVP(stat){
      const m = {
        'Points':'PTS','Rebounds':'REB','Assists':'AST','Threes':'3PM','Steals':'STL','Blocks':'BLK','Turnovers':'TOV',
        'Pts+Rebs':'PTS+REB','Pts+Asts':'PTS+AST','Rebs+Asts':'REB+AST','Pts+Rebs+Asts':'PTS+REB+AST','Fantasy Score':'FPTS'
      };
      return m[stat] || stat;
    // Manual refresh button: refetch odds and update badge immediately
    (function(){
      const btn = document.getElementById('refreshBtn');
      if(!btn) return;
      btn.addEventListener('click', async () => {
        btn.disabled = true; const old = btn.textContent; btn.textContent = 'Refreshing...';
        try{
          const r = await fetch('data/odds/latest.json', { cache: 'no-store' });
          if (r.ok){
            const latest = await r.json();
            const when = latest && latest.meta && latest.meta.generated_at ? new Date(latest.meta.generated_at) : null;
            const badge = document.getElementById('oddsMeta');
            if (badge && when) badge.textContent = `Odds: ${when.toLocaleTimeString()}`;
            console.log('[CGEDGE] Manual odds refresh:', when ? when.toLocaleString() : 'unknown');
          }
        } catch(e){ console.warn('[CGEDGE] Manual refresh failed', e); }
        btn.disabled = false; btn.textContent = old;
      });
    })();
    }

    function mapStatToRankField(stat){
      const s = mapStatToDVP(stat).toUpperCase();
      const rankMap = {
        'PTS':'pts_rank',
        'REB':'reb_rank',
        'AST':'ast_rank',
        '3PM':'pt3_rank',
        'STL':'stl_rank',
        'BLK':'blk_rank',
        // combos & fantasy: use DK points rank as proxy
        'PTS+REB':'dkpts_rank',
        'PTS+AST':'dkpts_rank',
        'REB+AST':'dkpts_rank',
        'PTS+REB+AST':'dkpts_rank',
        'FPTS':'dkpts_rank'
      };
      return rankMap[s] || 'avg_dfs';
    }

    function normalizeTeamCode(team){
      const t = String(team||'').toUpperCase();
      const map = {
        'BKN':'BRO','BRK':'BRO',
        'CHA':'CHA','CHO':'CHA',
        'PHX':'PHO','PHO':'PHO',
        'NOP':'NOP','NO':'NOP','NOR':'NOP',
        'UTA':'UTA','UTH':'UTA',
        'GSW':'GSW','GOL':'GSW',
        'NYK':'NYK','NY':'NYK'
      };
      return map[t] || t;
    }

    function computeCardDVP(opponent, position, stat){
      if(!Array.isArray(dvpRankings) || !opponent || !position) return null;
      const posKey = String(position||'').toUpperCase();
      const teamKey = normalizeTeamCode(opponent);
      const rows = dvpRankings.filter(r => String(r.team||'').toUpperCase()===teamKey && String(r.position||'').toUpperCase()===posKey);
      if(!rows.length) return null;
      const field = mapStatToRankField(stat);
      const raw = rows[0][field];
      if (raw === '-' || raw === undefined || raw === null) return null;
      const num = typeof raw === 'number' ? raw : Number(raw);
      if (isNaN(num)) return null;
      // Hide extreme/invalid ranks above 30
      if (Number(num) > 30) return null;
      return num;
    }

    function dvpClassByRank(rank){
      if (rank == null) return '';
      const r = Math.round(Number(rank));
      if (r <= 8) return 'dvp-red';      // tough
      if (r <= 22) return 'dvp-neutral'; // middling
      return 'dvp-green';                 // easy
    }

    function renderCards(players) {
      const container = document.getElementById('cards');
      container.innerHTML = '';

      if (players.length === 0) {
        container.innerHTML = '<div class="no-results">No edges found. Adjust filters.</div>';
        return;
      }

      players.forEach(player => {
        const slug = slugify(player.name);
        const playerUrl = `players/${slug}.html`;
        const pos = positionsMap[player.name] || positionsMap[Object.keys(positionsMap).find(k => k.toLowerCase() === player.name.toLowerCase())] || '';
        const posHTML = pos ? `<div class="position-chip">${pos}</div>` : '';
        const dvpVal = computeCardDVP(player.opponent, pos, player.prop);
        const dvpHTML = dvpVal!=null ? `<div class="dvp-badge ${dvpClassByRank(dvpVal)}">DVP: ${Math.round(Number(dvpVal))}</div>` : '';

        const card = document.createElement('div');
        card.className = 'card';
        card.dataset.player = JSON.stringify({
          name: player.name,
          team: player.team,
          opponent: player.opponent,
          prop: player.prop,
          line: player.line
        });
        const imgUrl = bbrefHeadshot(player.name);
        const avatarTop = imgUrl ? `
          <div style="display:flex;justify-content:center;align-items:center;margin-bottom:10px;">
            <img src="${imgUrl}" alt="${player.name}" style="width:48px;height:48px;border-radius:50%;object-fit:cover;border:1px solid var(--pp-border);box-shadow:0 2px 8px rgba(0,0,0,0.35);" onerror="this.style.display='none'" />
          </div>
        ` : '';
        card.innerHTML = `
          ${dvpHTML}
          ${avatarTop}
          <div class="player-header" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:center;">
            <div class="player-name" onclick="window.location.href='${playerUrl}'">${player.name}</div>
            ${posHTML}
            <div class="team">${player.team}</div>
          </div>
          <div class="opponent" style="text-align:center;">vs ${player.opponent}</div>
          <div class="prop-line" style="justify-content:center;gap:10px;">
            <select class="prop-select" style="background:rgba(57,217,169,0.15);border:1px solid var(--pp-success);color:white;border-radius:10px;padding:6px 10px;font-weight:700">
              <option value="${player.prop}" selected>${player.prop}</option>
              ${["Points","Rebounds","Assists","Threes","Fantasy Score","Steals","Blocks","Turnovers","Steals + Blocks","Pts+Rebs+Asts","Pts+Rebs","Pts+Asts","Rebs+Asts"]
                .filter(p=>p!==player.prop)
                .map(p=>`<option value="${p}">${p}</option>`).join('')}
            </select>
            <select class="side-select" style="background:#232832;border:1px solid var(--pp-border);color:white;border-radius:10px;padding:6px 10px;font-weight:700">
              <option value="Over" selected>Over</option>
              <option value="Under">Under</option>
            </select>
            <span>Line: ${player.line} • Proj: ${
              typeof player.projection === 'number'
                ? Number(player.projection).toFixed(1)
                : (typeof player.projection === 'string' && !isNaN(Number(player.projection))
                    ? Number(player.projection).toFixed(1)
                    : 'N/A')
            }</span>
            <button class="add-to-slip" style="background:#232832;color:#ffd43b;border:1px solid #ffd43b55;border-radius:10px;padding:6px 10px;font-weight:700;cursor:pointer">Add</button>
          </div>
          <div class="stats-grid">
            <div class="stat-box"><div class="label">Last 5</div><div class="value ${getColor(player.last_5_pct)}">${player.last_5} <small>(${player.last_5_pct}%)</small></div></div>
            <div class="stat-box"><div class="label">Last 10</div><div class="value ${getColor(player.last_10_pct)}">${player.last_10} <small>(${player.last_10_pct}%)</small></div></div>
            <div class="stat-box"><div class="label">Last 20</div><div class="value ${getColor(player.last_20_pct)}">${player.last_20} <small>(${player.last_20_pct}%)</small></div></div>
            <div class="stat-box"><div class="label">Full Season</div><div class="value ${getColor(player.season_pct)}">${player.season.split(' ')[0]} <small>(${player.season_pct}%)</small></div></div>
          </div>
        `;
        container.appendChild(card);
      });
    }

    // Slip builder state
    const selectedProps = [];
    function updateSlipBar(){
      const bar = document.getElementById('slipBar');
      const items = document.getElementById('slipItems');
      const countChip = document.getElementById('slipCount');
      const inlineCount = document.getElementById('slipInlineCount');
      if (!bar || !items) return;
      bar.style.display = selectedProps.length ? 'block' : 'none';
      items.innerHTML = selectedProps.map((it,idx)=>
        `<div style="display:flex;align-items:center;gap:8px;background:#1a2028;border:1px solid var(--pp-border);border-radius:12px;padding:6px 8px">
           <span style="color:#fff;font-weight:700">${it.prop} (${it.side||'Over'})</span>
           <span style="color:#39d9a9;font-weight:700">${it.name}</span>
           <span style="color:#ffd43b">${it.line}</span>
           <button data-remove="${idx}" style="background:#2a2f37;color:#ff6b6b;border:1px solid #ff6b6b66;border-radius:8px;padding:4px 8px;cursor:pointer">Remove</button>
         </div>`
      ).join('');
      localStorage.setItem('ppSlip', JSON.stringify({ version:1, items: selectedProps }));
      if (countChip){
        countChip.style.display = 'inline-block';
        countChip.textContent = `Slip: ${selectedProps.length}/6`;
      }
      if (inlineCount){
        inlineCount.style.display = selectedProps.length ? 'inline-block' : 'none';
        inlineCount.textContent = `${selectedProps.length}/6 selected`;
      }
      // Disable add buttons if at max
      const addButtons = document.querySelectorAll('.add-to-slip');
      addButtons.forEach(btn => {
        btn.disabled = selectedProps.length >= 6;
        btn.style.opacity = selectedProps.length >= 6 ? '0.6' : '1';
        btn.title = selectedProps.length >= 6 ? 'Max 6 props reached' : 'Add to slip';
      });
      // Disable buttons for duplicates (same player+prop already in slip)
      const cards = document.querySelectorAll('.card');
      cards.forEach(card => {
        const base = JSON.parse(card.dataset.player||'{}');
        const propSel = card.querySelector('.prop-select');
        const prop = propSel ? propSel.value : base.prop;
        const exists = selectedProps.some(sp => sp.name===base.name && sp.prop===prop);
        const btn = card.querySelector('.add-to-slip');
        if (btn){
          const atMax = selectedProps.length >= 6;
          btn.disabled = exists || atMax;
          btn.style.opacity = (exists || atMax) ? '0.6' : '1';
          btn.title = exists ? 'Already added' : (atMax ? 'Max 6 props reached' : 'Add to slip');
        }
      });
    }

    document.addEventListener('click', (e)=>{
      const addBtn = e.target.closest('.add-to-slip');
      if (addBtn){
        // Collect data from card
        const card = addBtn.closest('.card');
        if (!card) return;
        if (selectedProps.length >= 6){ alert('Max 6 props per slip'); return; }
        const base = JSON.parse(card.dataset.player||'{}');
        const propSel = card.querySelector('.prop-select');
        const prop = propSel ? propSel.value : base.prop;
        const sideSel = card.querySelector('.side-select');
        const side = sideSel ? sideSel.value : 'Over';
        // Prevent duplicates of same player+prop
        const isDup = selectedProps.some(sp => sp.name===base.name && sp.prop===prop && sp.side===side);
        if (isDup) { return; }
        const item = { name: base.name, team: base.team, opponent: base.opponent, prop, line: base.line, side };
        selectedProps.push(item);
        updateSlipBar();
      }
      const rmBtn = e.target.closest('[data-remove]');
      if (rmBtn){
        const idx = Number(rmBtn.getAttribute('data-remove'));
        if (!isNaN(idx)){ selectedProps.splice(idx,1); updateSlipBar(); }
      }
    });

    document.getElementById('clearSlip').addEventListener('click', ()=>{
      selectedProps.splice(0, selectedProps.length);
      updateSlipBar();
    });

    // Review modal
    const slipModal = document.getElementById('slipModal');
    document.getElementById('reviewSlip').addEventListener('click', ()=>{
      const sum = document.getElementById('slipSummary');
      sum.innerHTML = selectedProps.map(it=>
        `<div style="display:flex;align-items:center;justify-content:space-between;background:#1a2028;border:1px solid var(--pp-border);border-radius:12px;padding:8px 10px">
           <div style="display:flex;gap:10px;align-items:center">
             <strong style="color:#39d9a9">${it.name}</strong>
             <span style="color:#fff">${it.prop}</span>
             <span style="color:#ffd43b">${it.line}</span>
             <span style="color:#f87272">vs ${it.opponent}</span>
           </div>
        </div>`
      ).join('');
      slipModal.style.display = 'flex';
    });
    document.getElementById('closeSlip').addEventListener('click', ()=>{ slipModal.style.display='none'; });
    slipModal.addEventListener('click', (e)=>{ if(e.target===slipModal) slipModal.style.display='none'; });

    // Actions: Copy and Open PrizePicks
    document.getElementById('copySlip').addEventListener('click', async ()=>{
      const text = selectedProps.map(it=>`${it.prop} • ${it.name} • ${it.line} • vs ${it.opponent}`).join('\n');
      const payload = JSON.stringify({ version:1, items:selectedProps }, null, 2);
      try{
        await navigator.clipboard.writeText(text + '\n\n' + payload);
        alert('Slip copied to clipboard');
      }catch(e){ alert('Copy failed'); }
    });
    document.getElementById('openPP').addEventListener('click', ()=>{
      // Persist locally and pass slip via URL hash to PrizePicks (cross-origin safe)
      const payload = { version:1, items:selectedProps };
      const raw = JSON.stringify(payload);
      localStorage.setItem('ppSlip', raw);
      try{
        const encoded = btoa(unescape(encodeURIComponent(raw)));
        // Store and log cgpp for Playwright usage
        try{
          localStorage.setItem('cgppLast', encoded);
          console.log('[CGEDGE]', 'cgpp payload:', encoded);
        }catch(e){}
        window.open('https://app.prizepicks.com/#cgpp='+encoded, '_blank');
      }catch(e){
        window.open('https://app.prizepicks.com/', '_blank');
      }
    });

    // Copy cgpp helper
    document.getElementById('copyCgpp').addEventListener('click', async ()=>{
      try{
        const base64 = localStorage.getItem('cgppLast');
        if (!base64){ alert('No cgpp found. Click Open PrizePicks first.'); return; }
        await navigator.clipboard.writeText(base64);
        alert('cgpp copied to clipboard');
      }catch(e){ alert('Copy failed'); }
    });

    function filterAndSort() {
      const search = document.getElementById('search').value.toLowerCase();
      const stat = document.getElementById('statFilter').value;
      const teamSel = document.getElementById('teamFilter').value;
      const minHit = parseFloat(document.getElementById('minHitFilter').value);
      const period = document.getElementById('hitPeriod').value;
      const projSort = document.getElementById('projectionSort').value;
      const dvpSort = document.getElementById('dvpSort').value;
      const posSort = document.getElementById('positionSort').value;

      let filtered = allPlayers.filter(p => {
        const matchesSearch = p.name.toLowerCase().includes(search);
        const matchesStat = !stat || p.prop === stat;
        const matchesTeam = !teamSel || String(p.team).toUpperCase() === String(teamSel).toUpperCase();
        const matchesHit = p[period] >= minHit;
        return matchesSearch && matchesStat && matchesTeam && matchesHit;
      });

      if (posSort !== 'none') {
        if (posSort === 'customAsc') {
          filtered.sort((a,b) => positionOrderIndex(getPositionFor(a.name)) - positionOrderIndex(getPositionFor(b.name)));
        } else {
          filtered.sort((a,b) => positionOrderIndex(getPositionFor(b.name)) - positionOrderIndex(getPositionFor(a.name)));
        }
      } else if (dvpSort !== 'none') {
        const dvpOf = (p) => {
          const pos = getPositionFor(p.name);
          const val = computeCardDVP(p.opponent, pos, p.prop);
          return (val==null || isNaN(Number(val))) ? null : Number(val);
        };
        if (dvpSort === 'asc') {
          filtered.sort((a,b) => {
            const da = dvpOf(a); const db = dvpOf(b);
            if (da==null && db==null) return 0;
            if (da==null) return 1; // nulls last
            if (db==null) return -1;
            return da - db;
          });
        } else {
          filtered.sort((a,b) => {
            const da = dvpOf(a); const db = dvpOf(b);
            if (da==null && db==null) return 0;
            if (da==null) return 1; // nulls last
            if (db==null) return -1;
            return db - da;
          });
        }
      } else if (projSort === 'asc') {
        filtered.sort((a, b) => {
          const pa = typeof a.projection === 'number' ? a.projection : Number.POSITIVE_INFINITY;
          const pb = typeof b.projection === 'number' ? b.projection : Number.POSITIVE_INFINITY;
          return pa - pb;
        });
      } else if (projSort === 'desc') {
        filtered.sort((a, b) => {
          const pa = typeof a.projection === 'number' ? a.projection : Number.NEGATIVE_INFINITY;
          const pb = typeof b.projection === 'number' ? b.projection : Number.NEGATIVE_INFINITY;
          return pb - pa;
        });
      } else {
        filtered.sort((a, b) => b[period] - a[period]);
      }
      renderCards(filtered);
    }

    // Load data + positions with fallback to WITH_DVP
    const loadPlayers = async () => {
      try {
        const res1 = await fetch('PLAYER_UI_CARDS_PERFECT.json');
        if (res1.ok) return await res1.json();
        const res2 = await fetch('PLAYER_UI_CARDS_WITH_DVP.json');
        if (res2.ok) return await res2.json();
        throw new Error('Both PLAYER_UI_CARDS_PERFECT.json and PLAYER_UI_CARDS_WITH_DVP.json not found');
      } catch (e) {
        console.error('Failed loading player UI cards:', e);
        throw e;
      }
    };

    Promise.all([
      loadPlayers(),
      fetch('nba_players_2025_26_positions.json').then(r => r.ok ? r.json() : ({})),
      fetch('nba_dvp_latest.json').then(async r => {
        if (!r.ok) return {};
        try {
          const j = await r.json();
          // Support multiple shapes: {data:{team_dvp_rankings:[]}}, {team_dvp_rankings:[]}, or []
          const arr = (j && j.data && Array.isArray(j.data.team_dvp_rankings)) ? j.data.team_dvp_rankings
                    : (Array.isArray(j.team_dvp_rankings) ? j.team_dvp_rankings
                    : (Array.isArray(j) ? j : []));
          return { _raw: j, team_dvp_rankings: arr };
        } catch(e){ console.warn('[CGEDGE] DVP parse failed', e); return {}; }
      }),
      fetch('PLAYER_UI_CARDS_PERFECT.meta.json').then(r => r.ok ? r.json() : ({})),
      fetch('data/odds/latest.json').then(r => r.ok ? r.json() : ({ events: [] }))
    ])
      .then(([data, pos, dvp, meta, odds]) => {
        allPlayers = Array.isArray(data) ? data : (data.players || []);
        positionsMap = pos || {};
        dvpRankings = (dvp && Array.isArray(dvp.team_dvp_rankings)) ? dvp.team_dvp_rankings : [];
        // Console confirmations for data freshness
        try {
          const last = (meta && meta.generated_at) ? new Date(meta.generated_at) : null;
          if (last) console.log('[CGEDGE] Cards last updated:', last.toLocaleString());
          const dvpTimeRaw = (dvp && dvp._raw && dvp._raw.generated_at) || (dvp && dvp.generated_at);
          if (dvpTimeRaw) {
            const dt = new Date(dvpTimeRaw);
            console.log('[CGEDGE] DVP updated:', dt.toLocaleString());
          } else {
            console.warn('[CGEDGE] DVP rankings empty or missing; badges disabled until data arrives');
          }
          const oddsMeta = (odds && odds.meta && odds.meta.generated_at) ? new Date(odds.meta.generated_at) : null;
          const eventsCount = (odds && Array.isArray(odds.events)) ? odds.events.length : 0;
          if (oddsMeta) {
            console.log('[CGEDGE] Odds fetched:', oddsMeta.toLocaleString(), 'events:', eventsCount);
            const badge = document.getElementById('oddsMeta');
            if (badge) badge.textContent = `Odds: ${oddsMeta.toLocaleTimeString()}`;
          }
        } catch(e) {}
        // Show today matchup count badge
        try {
          const mEl = document.getElementById('matchupCount');
          const count = (odds && Array.isArray(odds.events)) ? odds.events.length : 0;
          if (mEl) mEl.textContent = count > 0 ? String(count) : '';
        } catch(e) {}
        // Populate player suggestions (unique names)
        const names = Array.from(new Set(allPlayers.map(p => p.name))).sort();
        const dl = document.getElementById('playerSuggestions');
        dl.innerHTML = '';
        names.forEach(n => {
          const opt = document.createElement('option');
          opt.value = n;
          dl.appendChild(opt);
        });
        // Populate team filter
        const teams = Array.from(new Set(allPlayers.map(p => String(p.team)))).filter(Boolean).sort();
        const teamSelect = document.getElementById('teamFilter');
        teams.forEach(t => {
          const opt = document.createElement('option');
          opt.value = t;
          opt.textContent = t;
          teamSelect.appendChild(opt);
        });
        filterAndSort();

        // Client-side odds refresh every 5 minutes to keep badge current
        async function refreshOddsBadge(){
          try{
            const r = await fetch('data/odds/latest.json', { cache: 'no-store' });
            if(!r.ok) return;
            const latest = await r.json();
            const when = latest && latest.meta && latest.meta.generated_at ? new Date(latest.meta.generated_at) : null;
            const badge = document.getElementById('oddsMeta');
            if (badge && when) badge.textContent = `Odds: ${when.toLocaleTimeString()}`;
          }catch(e){ console.warn('[CGEDGE] odds badge refresh failed', e); }
        }
        setInterval(refreshOddsBadge, 5 * 60 * 1000);
        // Also refresh once after 30s to quickly pick up new run
        setTimeout(refreshOddsBadge, 30 * 1000);
      })
      .catch(err => {
        console.error('Dashboard init error:', err);
        const msg = (err && err.message) ? err.message : 'Unknown error loading data';
        document.getElementById('cards').innerHTML = 
          `<div style="text-align:center;color:#ff6b6b">
            <h2>Error loading player data</h2>
            <div style="margin-top:8px;font-size:14px;opacity:0.9">${msg}</div>
          </div>`;
      });

    // Live filtering
    document.getElementById('search').addEventListener('input', filterAndSort);
    // Navigate to player page on Enter if exact match
    document.getElementById('search').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const name = e.target.value.trim();
        const match = allPlayers.find(p => p.name.toLowerCase() === name.toLowerCase());
        if (match) {
          const slug = slugify(match.name);
          window.location.href = `players/${slug}.html`;
        } else {
          filterAndSort();
        }
      }
    });
    document.getElementById('statFilter').addEventListener('change', filterAndSort);
    document.getElementById('teamFilter').addEventListener('change', filterAndSort);
    document.getElementById('minHitFilter').addEventListener('change', filterAndSort);
    document.getElementById('hitPeriod').addEventListener('change', filterAndSort);
    document.getElementById('projectionSort').addEventListener('change', filterAndSort);
    document.getElementById('dvpSort').addEventListener('change', filterAndSort);
    document.getElementById('positionSort').addEventListener('change', filterAndSort);
  </script>
</body>
</html>
<script>
// CGPP helper: capture and log the latest slip payload for Playwright usage
(function(){
  function saveCgpp(base64){
    try{
      localStorage.setItem('cgppLast', base64);
      console.log('[CGEDGE]', 'cgpp payload:', base64);
    }catch(e){}
  }
  // Hook into global open-to-PP if present
  const origOpen = window.openToPrizePicks;
  if (typeof origOpen === 'function'){
    window.openToPrizePicks = function(urlWithHash, base64){
      if (base64) saveCgpp(base64);
      return origOpen(urlWithHash);
    };
  }
  // Fallback: intercept clicks on buttons/links that include cgpp in hash
  document.addEventListener('click', (e)=>{
    const a = e.target.closest('a,button');
    if (!a) return;
    const href = a.getAttribute('href') || '';
    const hash = (href || location.hash || '');
    if (hash.includes('cgpp=')){
      try{
        const u = new URL(href.startsWith('http') ? href : (location.origin + href));
        const base64 = u.searchParams.get('cgpp') || (u.hash||'').replace(/^#.*cgpp=/,'');
        if (base64) saveCgpp(base64);
      }catch(e){}
    }
  }, true);
})();
</script>
</html>