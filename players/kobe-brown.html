<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Kobe Brown • CGEDGE</title>
  <script src="https://code.highcharts.com/highcharts.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Roboto:wght@400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="../style.css" />
</head>
<body class="player-page">
  <a href="../index.html" class="back">Home</a>

  <header>
    <h1>CGEDGE</h1>
    <div class="tag">WEAPONIZED STATS.</div>
  </header>

  <div class="wrap">
    <!-- SINGLE panel: everything (badges, image, content) lives in here -->
    <div class="panel">
      <!-- Corner badges -->
      <div id="dvpBadge" class="dvp-badge" style="display:none;"></div>
      <div id="minBadge" class="min-badge" style="display:none;"></div>
      <div id="spreadBadge" class="spread-badge" style="display:none;"></div>

      <!-- Player image -->
      <div class="player-img-container">
        <img id="playerHeadshot" src="https://www.basketball-reference.com/req/202106291/images/players/brownko01.jpg" alt="Kobe Brown">
      </div>

      <!-- Name + meta -->
      <div class="name">Kobe Brown</div>
      <div class="meta-line">
        <div class="position" id="positionChip"></div>
        <div class="team"></div>
        <div class="opponent">vs N/A</div>
      </div>

      <!-- Prop line -->
      <div class="prop-line">
        <select id="propSelect">
          <option value="Pts+Rebs+Asts">Pts+Rebs+Asts</option>
        </select>
        • Line <strong id="lineVal">8.1</strong> 
        • Projection <strong id="projectionVal">8.4</strong>
        <!-- Exp Min inline removed; now shown as top-left badge -->
        <span id="edgeBadge"></span>
      </div>

      <!-- Last N slider -->
      <div class="lastn" style="display:flex;align-items:center;gap:12px;justify-content:center;margin-top:10px;">
        <label for="lastNSlider" style="color:var(--pp-accent);font-weight:700">Last <span id="lastNValue">10</span> games</label>
        <input id="lastNSlider" type="range" min="5" max="30" step="1" value="10" style="width:220px;"/>
      </div>

      <!-- Hitrates -->
      <div class="hitrates-wrapper">
        <div class="hitrates">
          <div class="rate-box" data-n="5"><div class="label">Last 5</div><div class="val">4/5</div></div>
          <div class="rate-box" data-n="10"><div class="label">Last 10</div><div class="val">5/10</div></div>
          <div class="rate-box" data-n="20"><div class="label">Last 20</div><div class="val">7/16</div></div>
          <div class="rate-box" data-n="season"><div class="label">Season</div><div class="val">7/16</div></div>
        </div>
        <div class="dots">
          <span class="dot active"></span>
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </div>
      </div>

      <!-- Chart -->
      <div id="chart"></div>
    </div>
  </div>

  <script>
    let line = Number('8.1');
    let data = JSON.parse('[5.0, 1.0, 3.0, 3.0, 9.0, 11.0, 5.0, 13.0, 0.0, 4.0, 8.0, 5.0, 9.0, 10.0, 9.0, 18.0]');
    let dates = JSON.parse('["10/22", "10/24", "10/28", "11/04", "11/06", "11/10", "11/12", "11/20", "11/22", "11/23", "11/25", "11/28", "11/29", "12/01", "12/03", "12/05"]');
    let lastN = 10;
    let projection = Number('8.4');
    const playerName = 'Kobe Brown';

    (function(){
      const img = document.getElementById('playerHeadshot');
      if(!img) return;
      const container = img.parentElement;
      const initials = ("Kobe Brown"||'').split(/\s+/).map(p=>p[0]||'').slice(0,2).join('').toUpperCase();
      function showFallback(){
        const div = document.createElement('div');
        div.className = 'avatar-fallback';
        div.textContent = initials || 'PP';
        try { container.replaceChild(div, img); } catch(e) {}
      }
      img.addEventListener('error', showFallback, { once: true });
    })();

    async function fetchPlayerProps(name){
      try{
        const res = await fetch('../PLAYER_UI_CARDS_PERFECT.json');
        const all = await res.json();
        return all.filter(r => (r.Name || r.name || '').toLowerCase() === String(name).toLowerCase());
      }catch(e){
        console.warn('Failed to fetch player props', e);
        return [];
      }
    }

    async function fetchPositions(){
      try{
        const res = await fetch('../nba_players_2025_26_positions.json');
        if(!res.ok) return {};
        return await res.json();
      }catch(e){
        console.warn('Failed to fetch positions', e);
        return {};
      }
    }

    async function fetchDVP(){
      try{
        const res = await fetch('../nba_dvp_latest.json');
        if(!res.ok) return [];
        const payload = await res.json();
        const rankings = (payload && payload.data && Array.isArray(payload.data.team_dvp_rankings)) ? payload.data.team_dvp_rankings
                        : (Array.isArray(payload.team_dvp_rankings) ? payload.team_dvp_rankings
                        : (Array.isArray(payload) ? payload : []));
        if (!rankings.length) console.warn('DVP rankings empty; badge will be hidden until data is available');
        return rankings;
      }catch(e){
        console.warn('Failed to fetch DVP', e);
        return [];
      }
    }

    function mapStatToDVP(stat){
      const m = {
        'Points':'PTS','Rebounds':'REB','Assists':'AST','Threes':'3PM','Steals':'STL','Blocks':'BLK','Turnovers':'TOV',
        'Pts+Rebs':'PTS+REB','Pts+Asts':'PTS+AST','Rebs+Asts':'REB+AST','Pts+Rebs+Asts':'PTS+REB+AST','Fantasy Score':'FPTS'
      };
      return m[stat] || stat;
    }

    function mapStatToRankField(stat){
      const s = mapStatToDVP(stat).toUpperCase();
      const rankMap = {
        'PTS':'pts_rank',
        'REB':'reb_rank',
        'AST':'ast_rank',
        '3PM':'pt3_rank',
        'STL':'stl_rank',
        'BLK':'blk_rank',
        'PTS+REB':'dkpts_rank',
        'PTS+AST':'dkpts_rank',
        'REB+AST':'dkpts_rank',
        'PTS+REB+AST':'dkpts_rank',
        'FPTS':'dkpts_rank'
      };
      return rankMap[s] || 'avg_dfs';
    }

    function normalizeTeamCode(team){
      const t = String(team||'').toUpperCase();
      const map = {
        'BKN':'BRO','BRK':'BRO',
        'CHO':'CHA','CHA':'CHA',
        'PHX':'PHO','PHO':'PHO',
        'NO':'NOP','NOR':'NOP','NOP':'NOP',
        'NY':'NYK','NYK':'NYK',
        'UTH':'UTA','UTA':'UTA',
        'GOL':'GSW','GS':'GSW','GSW':'GSW'
      };
      return map[t] || t;
    }

    function computeDVP(rankings, team, position, stat){
      if(!Array.isArray(rankings)) return null;
      const posKey = String(position||'').toUpperCase();
      const teamKey = normalizeTeamCode(team);
      const rows = rankings.filter(r => String(r.team||'').toUpperCase()===teamKey && String(r.position||'').toUpperCase()===posKey);
      if(!rows.length) return null;
      const field = mapStatToRankField(stat);
      const raw = rows[0][field];
      if (raw === '-' || raw == null) return null;
      const num = typeof raw === 'number' ? raw : Number(raw);
      if (isNaN(num)) return null;
      // Hide extreme/invalid ranks above 30
      if (Number(num) > 30) return null;
      return num;
    }

    function dvpClassByRank(rank){
      if (rank == null) return '';
      const r = Math.round(Number(rank));
      if (r <= 8) return 'dvp-red';
      if (r <= 22) return 'dvp-neutral';
      return 'dvp-green';
    }

    function renderBadge(){
      const badgeEl = document.getElementById('edgeBadge');
      if(!badgeEl || !Array.isArray(data) || !data.length) return;
      const avg = data.reduce((a,b)=>a+b,0)/data.length;
      if(avg > line + 0.5) badgeEl.innerHTML = '<span class="badge-hot">STRONG EDGE</span>';
      else if(avg > line) badgeEl.innerHTML = '<span class="badge-hot">EDGE</span>';
      else if(avg < line - 0.5) badgeEl.innerHTML = '<span class="badge-cold">UNDER</span>';
      else badgeEl.innerHTML = '';
    }

    function renderMinutesBadge(record){
      const minutesEl = document.getElementById('minBadge');
      if (!minutesEl) return;
      const val = record?.expected_minutes ?? record?.ExpectedMinutes ?? record?.minutes;
      const tmpl = '{{EXPECTED_MINUTES}}';
      let m = val;
      if (m == null || m === '' || m === 'undefined') {
        m = (tmpl && tmpl !== '{{EXPECTED_MINUTES}}') ? Number(tmpl) : null;
      }
      if (m == null || isNaN(Number(m))) {
        minutesEl.style.display = 'none';
        minutesEl.textContent = '';
        minutesEl.className = 'min-badge';
        // Also hide spread badge if minutes are hidden
        const spreadEl = document.getElementById('spreadBadge');
        if (spreadEl) { spreadEl.style.display = 'none'; spreadEl.textContent = ''; spreadEl.className = 'spread-badge'; }
        return;
      }
      const num = Number(m);
      minutesEl.textContent = `${num.toFixed(1)} MIN`;
      let cls = 'min-badge ';
      // Simplified color scale: 30+ minutes → green, otherwise red
      if (num >= 30) cls += 'dvp-green';
      else cls += 'dvp-red';
      minutesEl.className = cls;
      minutesEl.style.display = 'block';

      // --- Spread badge logic ---
      const spreadEl = document.getElementById('spreadBadge');
      if (!spreadEl) return;
      // Helper for color class
      function spreadClassByValue(val) {
        if (typeof val !== 'number') val = Number(val);
        if (isNaN(val)) return '';
        if (Math.abs(val) >= 7) return 'spread-red';
        return 'spread-green';
      }
      // Fetch odds and show spread for opponent
      fetch('../data/odds/latest.json').then(r => r.ok ? r.json() : { events: [] }).then(oddsData => {
        const TEAM_ABBR_TO_FULL = {
          'ATL': 'Atlanta Hawks', 'BOS': 'Boston Celtics', 'BKN': 'Brooklyn Nets', 'BRK': 'Brooklyn Nets',
          'CHA': 'Charlotte Hornets', 'CHO': 'Charlotte Hornets', 'CHI': 'Chicago Bulls', 'CLE': 'Cleveland Cavaliers',
          'DAL': 'Dallas Mavericks', 'DEN': 'Denver Nuggets', 'DET': 'Detroit Pistons', 'GSW': 'Golden State Warriors',
          'HOU': 'Houston Rockets', 'IND': 'Indiana Pacers', 'LAC': 'Los Angeles Clippers', 'LAL': 'Los Angeles Lakers',
          'MEM': 'Memphis Grizzlies', 'MIA': 'Miami Heat', 'MIL': 'Milwaukee Bucks', 'MIN': 'Minnesota Timberwolves',
          'NOP': 'New Orleans Pelicans', 'NO': 'New Orleans Pelicans', 'NYK': 'New York Knicks', 'NY': 'New York Knicks',
          'OKC': 'Oklahoma City Thunder', 'ORL': 'Orlando Magic', 'PHI': 'Philadelphia 76ers', 'PHX': 'Phoenix Suns',
          'PHO': 'Phoenix Suns', 'POR': 'Portland Trail Blazers', 'SAC': 'Sacramento Kings', 'SAS': 'San Antonio Spurs',
          'TOR': 'Toronto Raptors', 'UTA': 'Utah Jazz', 'UTH': 'Utah Jazz', 'WAS': 'Washington Wizards'
        };
        // Try to get opponent from record or template
        let oppAbbr = record?.Opp || record?.opponent || record?.OppTeam || record?.Versus || record?.versus || record?.Opp || 'N/A';
        oppAbbr = String(oppAbbr).toUpperCase();
        const fullName = TEAM_ABBR_TO_FULL[oppAbbr] || oppAbbr;
        let spread = null;
        if (oddsData && Array.isArray(oddsData.events)) {
          for (const event of oddsData.events) {
            if (event.home_team === fullName && event.best_spread && event.best_spread.home && typeof event.best_spread.home.point === 'number') {
              spread = event.best_spread.home.point;
              break;
            }
            if (event.away_team === fullName && event.best_spread && event.best_spread.away && typeof event.best_spread.away.point === 'number') {
              spread = event.best_spread.away.point;
              break;
            }
          }
        }
        if (spread !== null && spread !== undefined && spread !== '') {
          const spreadVal = Number(spread);
          const sign = spreadVal > 0 ? '+' : '';
          const spreadClass = spreadClassByValue(spreadVal);
          spreadEl.textContent = `Spread: ${sign}${spreadVal}`;
          spreadEl.className = `spread-badge ${spreadClass}`;
          spreadEl.style.display = 'block';
        } else {
          spreadEl.style.display = 'none';
          spreadEl.textContent = '';
          spreadEl.className = 'spread-badge';
        }
      }).catch(() => {
        const spreadEl = document.getElementById('spreadBadge');
        if (spreadEl) { spreadEl.style.display = 'none'; spreadEl.textContent = ''; spreadEl.className = 'spread-badge'; }
      });
    }

    function maxRange(){
      const len = Array.isArray(data) ? data.length : 0;
      return Math.max(5, len || 10);
    }

    function renderChart(nOverride) {
      try {
        let n = nOverride || lastN || 10;
        if (n === 'season') n = data.length;
        else n = Math.max(5, Math.min(maxRange(), Number(n)));
        const seriesData = Array.isArray(data) ? data.slice(-n) : [];
        // Use game dates from player gamelog if available
        let xCats = [];
        if (Array.isArray(dates) && dates.length >= n) {
          xCats = dates.slice(-n).map(d => {
            const date = new Date(d);
            if (isNaN(date)) return d.slice(5,10).replace('-','/');
            return (date.getMonth()+1) + '/' + date.getDate();
          });
        } else {
          xCats = seriesData.map((_, i) => {
            const gameIndex = data.length - n + i;
            const game = (window.playerGames || [])[gameIndex];
            if (game && game.date) {
              const date = new Date(game.date);
              if (!isNaN(date)) return (date.getMonth()+1) + '/' + date.getDate();
              return game.date;
            }
            return `G${n-i}`;
          });
        }
        Highcharts.chart('chart', {
          chart: { backgroundColor: 'var(--pp-surface-alt)' },
          title: { text: `Last ${n} Games`, style: { color: 'var(--pp-text-dim)', fontSize: '14px', fontWeight: '600' } },
          xAxis: {
            categories: xCats,
            title: { text: 'GAME DATE', style: { color: 'var(--pp-accent)', fontWeight: 'bold', fontSize: '13px' } },
            labels: {
              style: { color: 'var(--pp-text-dim)', fontSize: '11px', fontWeight: '500' },
              rotation: -45,
              align: 'right'
            }
          },
          yAxis: {
            title: { text: document.getElementById('propSelect').value, style: { color: 'var(--pp-text-dim)' } },
            gridLineColor: 'rgba(255,255,255,0.05)',
            plotLines: [{
              value: line,
              color: '#FBBF24',
              width: 2,
              dashStyle: 'Dash',
              label: { text: 'Line ' + line, style: { color: '#FBBF24', fontWeight: 'bold' } }
            }]
          },
          legend: { enabled: false },
          tooltip: {
            backgroundColor: 'var(--pp-surface)',
            borderColor: 'var(--pp-border)',
            style: { color: 'var(--pp-text)' },
            formatter: function() {
              return `<b>${this.y}</b> ${document.getElementById('propSelect').value}<br/>${xCats[this.point.index]}`;
            }
          },
          series: [{
            type: 'column',
            name: 'Kobe Brown',
            data: seriesData.map(v => ({
              y: v,
              color: v > line ? 'var(--pp-success)' : 'var(--pp-danger)'
            })),
            borderRadius: 4
          }]
        });
      } catch(e) {
        console.error("Chart render failed:", e);
        document.getElementById('chart').innerHTML = '<div style="text-align:center;padding:40px;color:#ff6b6b;">Chart failed</div>';
      }
    }
    

    function renderHitrates(record){
      const boxes = document.querySelectorAll('.hitrates .rate-box .val');
      if(boxes.length < 4) return;
      const vals = [
        record.last_5 || '4/5',
        record.last_10 || '5/10',
        record.last_20 || '7/16',
        record.season || '7/16'
      ];
      vals.forEach((v, i) => {
        const { text, pct } = formatPercentFirstWithPct(v);
        boxes[i].textContent = text;
        boxes[i].classList.remove('hit-green','hit-neutral','hit-red');
        if (pct >= 75) boxes[i].classList.add('hit-green');
        else if (pct >= 60) boxes[i].classList.add('hit-neutral');
        else if (pct < 50) boxes[i].classList.add('hit-red');
        else boxes[i].classList.add('hit-neutral');
      });
    }

    function formatPercentFirstWithPct(ratioStr){
      const m = String(ratioStr).match(/^(\d+)\/(\d+)$/);
      if(!m) return { text: ratioStr, pct: NaN };
      const hits = Number(m[1]);
      const total = Number(m[2]) || 1;
      const pct = Math.round((hits/total)*100);
      return { text: `${pct}% • ${ratioStr}` , pct };
    }

    function syncSliderWithData(){
      const slider = document.getElementById('lastNSlider');
      const lbl = document.getElementById('lastNValue');
      if (!slider || !lbl) return;
      const maxLen = maxRange();
      slider.max = String(maxLen);
      // Default slider value to full season length
      slider.value = String(maxLen);
      lastN = Number(slider.value);
      lbl.textContent = String(lastN);
      // Add click listeners to hitrate blocks
      document.querySelectorAll('.hitrates .rate-box').forEach(box => {
        box.style.cursor = 'pointer';
        box.onclick = function() {
          let n = box.getAttribute('data-n');
          if (n === 'season') n = data.length;
          else n = Number(n);
          lastN = n;
          lbl.textContent = String(n);
          renderChart(n);
          // Highlight selected block
          document.querySelectorAll('.hitrates .rate-box').forEach(b => b.classList.remove('selected'));
          box.classList.add('selected');
        };
      });
    }

    function updateUI(record){
      line = Number(record.Line ?? record.line);
      const series = record.last_10_values ?? record.last10_values ?? record.last_10;
      data = Array.isArray(series) ? series : data;
      projection = record.projection ?? record.Proj ?? record.projected ?? projection;
      document.getElementById('lineVal').textContent = line;
      document.getElementById('projectionVal').textContent = typeof projection === 'number' ? projection.toFixed(1) : (projection ?? 'N/A');
      syncSliderWithData();
      renderMinutesBadge(record);
      renderBadge();
      renderHitrates(record);
      renderChart();
    }

    const hitratesEl = document.querySelector('.hitrates');
    const dots = document.querySelectorAll('.dot');
    function updateDots() {
      if (!hitratesEl) return;
      const index = Math.round(hitratesEl.scrollLeft / (hitratesEl.clientWidth + 12));
      dots.forEach((d, i) => d.classList.toggle('active', i === index));
    }
    if (hitratesEl) {
      hitratesEl.addEventListener('scroll', updateDots);
      window.addEventListener('resize', updateDots);
      updateDots();
    }

    (async function(){
      renderBadge();
      renderChart();
      renderHitrates({});

      const positionsMap = await fetchPositions();
      const posEl = document.getElementById('positionChip');
      let playerPosition = '';
      if (posEl && positionsMap) {
        const direct = positionsMap[playerName];
        if (direct) { posEl.textContent = direct; playerPosition = direct; }
        else {
          const key = Object.keys(positionsMap).find(k => k.toLowerCase() === playerName.toLowerCase());
          if (key) { posEl.textContent = positionsMap[key]; playerPosition = positionsMap[key]; }
          else posEl.style.display = 'none';
        }
      }

      const dvpRankings = await fetchDVP();
      function updateDVPDisplay(currentStat){
        let oppTeam = 'N/A';
        try {
          const key = currentStat;
          const rec = (Array.isArray(records) ? records : []).find(r => (r.Stat || r.stat || r.prop) === key) || null;
          const o = rec && (rec.Versus || rec.Opp || rec.opponent || rec.opp || rec.versus);
          if (o) oppTeam = o;
        } catch (e) {}
        const dvpVal = computeDVP(dvpRankings, String(oppTeam||'').toUpperCase(), playerPosition, currentStat);
        const badge = document.getElementById('dvpBadge');
        if (!badge) return;
        if (dvpVal == null) {
          badge.style.display = 'none';
          badge.textContent='';
          badge.className='dvp-badge';
          return;
        }
        const rankInt = Math.round(Number(dvpVal));
        badge.textContent = `DVP: ${rankInt}`;
        badge.className = `dvp-badge ${dvpClassByRank(rankInt)}`;
        badge.style.display = 'block';
      }

      const records = await fetchPlayerProps(playerName);
      const select = document.getElementById('propSelect');
      const current = select.value;
      const uniqueProps = Array.from(new Set(records.map(r => r.Stat || r.stat || r.prop))).filter(Boolean);
      const displayMap = { 'PRA': 'Pts+Rebs+Asts' };
      select.innerHTML = '';
      uniqueProps.forEach(p => {
        const disp = displayMap[p] || p;
        const opt = document.createElement('option');
        opt.value = disp; opt.textContent = disp;
        if(disp === current) opt.selected = true;
        select.appendChild(opt);
      });

      // Slider wiring: update label and re-render chart
      const slider = document.getElementById('lastNSlider');
      const lastLabel = document.getElementById('lastNValue');
      if (slider && lastLabel){
        // Initialize slider bounds with dataset length (up to 20)
        syncSliderWithData();
        slider.addEventListener('input', () => {
          lastN = Number(slider.value);
          lastLabel.textContent = String(lastN);
          renderChart();
        });
      }

      select.addEventListener('change', () => {
        const selected = select.value;
        const statKey = selected;
        const rec = records.find(r => (r.Stat || r.stat || r.prop) === statKey);
        if(rec) {
          // Update meta (team/opponent) if present in record
          const teamEl = document.querySelector('.meta-line .team');
          if (teamEl && (rec.Team || rec.team)) teamEl.textContent = rec.Team || rec.team;
          const oppEl = document.querySelector('.meta-line .opponent');
          const o = rec.Versus || rec.Opp || rec.opponent || rec.opp || rec.versus;
          if (oppEl && o) oppEl.textContent = 'vs ' + o;
          updateUI(rec);
        }
        updateDVPDisplay(selected);
      });
      // Initial render using record data if available
      (function(){
        const statKey = current;
        const rec = records.find(r => (r.Stat || r.stat || r.prop) === statKey) || records[0];
        if (rec) {
          const teamEl = document.querySelector('.meta-line .team');
          if (teamEl && (rec.Team || rec.team)) teamEl.textContent = rec.Team || rec.team;
          const oppEl = document.querySelector('.meta-line .opponent');
          const o = rec.Versus || rec.Opp || rec.opponent || rec.opp || rec.versus;
          if (oppEl && o) oppEl.textContent = 'vs ' + o;
          updateUI(rec);
        }
        updateDVPDisplay(current);
        // Ensure slider reflects current dataset and defaults to full season
        syncSliderWithData();
        renderChart();
      })();
    })();
  </script>
</body>
</html>
